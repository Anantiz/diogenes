Foo: pt= pthread
	-memeset  malloc  write  printf  gettimeofday
	-pt_detach  pt_join  pt_create  usleep
	-pt_mutex_destroy  pt_mutex_lock  pt_mutex_init
		pt_mutex_unlock

---------------------------------------------------------------------

.Each philosopher is a thread
	-They all have a Number
		- They are supposed to all sit in a circle
			The seat position is based on the number
			'0' is the first seat amd 'last' the last obviously
			the last is sitted next to the first one
			each neighbor (is n+1 or n-1) % number_of_philo
	-They are represented as a struct
		Each philosopher is entitled to two forks
		the struct has a left-right fork, it is a status code
TO-RESEARCH: How to represent forks states using only one variable and status codes ?
	-Each fork has a bit-value, 
	they are added or removed when they are used or available
	The philosophers left-right fork are just status code,
	neighboring philosophers should have the same status code for theyr fork

	-philosophers think once they are done sleeping and are waiting to eat

.The main thread is the table
	Forks are stored in a variable in the table thread
	The table thread is also the one who will summon everything


//IT's just a txt file and my projecti is in C, but it's a good way to tell pseudo code apart lmao
if __name__ == "__main__"

data = Parse_input(argv)
Init_shared_resources(data)
	{
		mutex	forks[philosophers_count];
	}

// Create a new thread for each philosopher, and tell them to do philosopher()
Init_philosophers(philosophers_count)

philosopher()
{
	self.last_meal = current_epoch
	While slef.Alive and self.meal_count < max_meal
		Change_state(self, THINK)
		Queue to lock shared forks
			Once both forks are locked
				Change_state (self, EAT)
				Eat (time_to_eat)
				self.last_meal = current_epoch
				Unlock forks
			if current_epoch - last_meal > time_to_die
				die
				EXIT() // failed to keep philosophers alive
		Change_state (self, SLEEP)
		Sleep (time_to_sleep)
}